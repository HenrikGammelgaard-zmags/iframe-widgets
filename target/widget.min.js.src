
/*
 RequireJS 2.1.1 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 Available via the MIT or new BSD license.
 see: http://github.com/jrburke/requirejs for details
*/
var requirejs,require,define;
(function(W){function D(b){return M.call(b)==="[object Function]"}function E(b){return M.call(b)==="[object Array]"}function t(b,c){if(b){var d;for(d=0;d<b.length;d+=1)if(b[d]&&c(b[d],d,b))break}}function N(b,c){if(b){var d;for(d=b.length-1;d>-1;d-=1)if(b[d]&&c(b[d],d,b))break}}function A(b,c){for(var d in b)if(b.hasOwnProperty(d)&&c(b[d],d))break}function O(b,c,d,g){c&&A(c,function(c,j){if(d||!F.call(b,j))g&&typeof c!=="string"?(b[j]||(b[j]={}),O(b[j],c,d,g)):b[j]=c});return b}function r(b,c){return function(){return c.apply(b,
arguments)}}function X(b){if(!b)return b;var c=W;t(b.split("."),function(b){c=c[b]});return c}function G(b,c,d,g){c=Error(c+"\nhttp://requirejs.org/docs/errors.html#"+b);c.requireType=b;c.requireModules=g;if(d)c.originalError=d;return c}function ba(){if(H&&H.readyState==="interactive")return H;N(document.getElementsByTagName("script"),function(b){if(b.readyState==="interactive")return H=b});return H}var g,s,u,y,q,B,H,I,Y,Z,ca=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,da=/[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
$=/\.js$/,ea=/^\.\//;s=Object.prototype;var M=s.toString,F=s.hasOwnProperty,fa=Array.prototype.splice,v=!!(typeof window!=="undefined"&&navigator&&document),aa=!v&&typeof importScripts!=="undefined",ga=v&&navigator.platform==="PLAYSTATION 3"?/^complete$/:/^(complete|loaded)$/,R=typeof opera!=="undefined"&&opera.toString()==="[object Opera]",w={},n={},P=[],J=!1;if(typeof define==="undefined"){if(typeof requirejs!=="undefined"){if(D(requirejs))return;n=requirejs;requirejs=void 0}typeof require!=="undefined"&&
!D(require)&&(n=require,require=void 0);g=requirejs=function(b,c,d,p){var i,j="_";!E(b)&&typeof b!=="string"&&(i=b,E(c)?(b=c,c=d,d=p):b=[]);if(i&&i.context)j=i.context;(p=w[j])||(p=w[j]=g.s.newContext(j));i&&p.configure(i);return p.require(b,c,d)};g.config=function(b){return g(b)};g.nextTick=typeof setTimeout!=="undefined"?function(b){setTimeout(b,4)}:function(b){b()};require||(require=g);g.version="2.1.1";g.jsExtRegExp=/^\/|:|\?|\.js$/;g.isBrowser=v;s=g.s={contexts:w,newContext:function(b){function c(a,
f,x){var e,m,b,c,d,h,i,g=f&&f.split("/");e=g;var j=k.map,l=j&&j["*"];if(a&&a.charAt(0)===".")if(f){e=k.pkgs[f]?g=[f]:g.slice(0,g.length-1);f=a=e.concat(a.split("/"));for(e=0;f[e];e+=1)if(m=f[e],m===".")f.splice(e,1),e-=1;else if(m==="..")if(e===1&&(f[2]===".."||f[0]===".."))break;else e>0&&(f.splice(e-1,2),e-=2);e=k.pkgs[f=a[0]];a=a.join("/");e&&a===f+"/"+e.main&&(a=f)}else a.indexOf("./")===0&&(a=a.substring(2));if(x&&(g||l)&&j){f=a.split("/");for(e=f.length;e>0;e-=1){b=f.slice(0,e).join("/");if(g)for(m=
g.length;m>0;m-=1)if(x=j[g.slice(0,m).join("/")])if(x=x[b]){c=x;d=e;break}if(c)break;!h&&l&&l[b]&&(h=l[b],i=e)}!c&&h&&(c=h,d=i);c&&(f.splice(0,d,c),a=f.join("/"))}return a}function d(a){v&&t(document.getElementsByTagName("script"),function(f){if(f.getAttribute("data-requiremodule")===a&&f.getAttribute("data-requirecontext")===h.contextName)return f.parentNode.removeChild(f),!0})}function p(a){var f=k.paths[a];if(f&&E(f)&&f.length>1)return d(a),f.shift(),h.require.undef(a),h.require([a]),!0}function i(a){var f,
b=a?a.indexOf("!"):-1;b>-1&&(f=a.substring(0,b),a=a.substring(b+1,a.length));return[f,a]}function j(a,f,b,e){var m,K,d=null,g=f?f.name:null,j=a,l=!0,k="";a||(l=!1,a="_@r"+(M+=1));a=i(a);d=a[0];a=a[1];d&&(d=c(d,g,e),K=o[d]);a&&(d?k=K&&K.normalize?K.normalize(a,function(a){return c(a,g,e)}):c(a,g,e):(k=c(a,g,e),a=i(k),d=a[0],k=a[1],b=!0,m=h.nameToUrl(k)));b=d&&!K&&!b?"_unnormalized"+(N+=1):"";return{prefix:d,name:k,parentMap:f,unnormalized:!!b,url:m,originalName:j,isDefine:l,id:(d?d+"!"+k:k)+b}}function n(a){var f=
a.id,b=l[f];b||(b=l[f]=new h.Module(a));return b}function q(a,f,b){var e=a.id,m=l[e];if(F.call(o,e)&&(!m||m.defineEmitComplete))f==="defined"&&b(o[e]);else n(a).on(f,b)}function z(a,f){var b=a.requireModules,e=!1;if(f)f(a);else if(t(b,function(f){if(f=l[f])f.error=a,f.events.error&&(e=!0,f.emit("error",a))}),!e)g.onError(a)}function s(){P.length&&(fa.apply(C,[C.length-1,0].concat(P)),P=[])}function u(a,f,b){var e=a.map.id;a.error?a.emit("error",a.error):(f[e]=!0,t(a.depMaps,function(e,c){var d=e.id,
g=l[d];g&&!a.depMatched[c]&&!b[d]&&(f[d]?(a.defineDep(c,o[d]),a.check()):u(g,f,b))}),b[e]=!0)}function w(){var a,f,b,e,m=(b=k.waitSeconds*1E3)&&h.startTime+b<(new Date).getTime(),c=[],g=[],i=!1,j=!0;if(!S){S=!0;A(l,function(b){a=b.map;f=a.id;if(b.enabled&&(a.isDefine||g.push(b),!b.error))if(!b.inited&&m)p(f)?i=e=!0:(c.push(f),d(f));else if(!b.inited&&b.fetched&&a.isDefine&&(i=!0,!a.prefix))return j=!1});if(m&&c.length)return b=G("timeout","Load timeout for modules: "+c,null,c),b.contextName=h.contextName,
z(b);j&&t(g,function(a){u(a,{},{})});if((!m||e)&&i)if((v||aa)&&!T)T=setTimeout(function(){T=0;w()},50);S=!1}}function y(a){n(j(a[0],null,!0)).init(a[1],a[2])}function B(a){var a=a.currentTarget||a.srcElement,b=h.onScriptLoad;a.detachEvent&&!R?a.detachEvent("onreadystatechange",b):a.removeEventListener("load",b,!1);b=h.onScriptError;a.detachEvent&&!R||a.removeEventListener("error",b,!1);return{node:a,id:a&&a.getAttribute("data-requiremodule")}}function I(){var a;for(s();C.length;)if(a=C.shift(),a[0]===
null)return z(G("mismatch","Mismatched anonymous define() module: "+a[a.length-1]));else y(a)}var S,U,h,L,T,k={waitSeconds:7,baseUrl:"./",paths:{},pkgs:{},shim:{},map:{},config:{}},l={},V={},C=[],o={},Q={},M=1,N=1;L={require:function(a){return a.require?a.require:a.require=h.makeRequire(a.map)},exports:function(a){a.usingExports=!0;if(a.map.isDefine)return a.exports?a.exports:a.exports=o[a.map.id]={}},module:function(a){return a.module?a.module:a.module={id:a.map.id,uri:a.map.url,config:function(){return k.config&&
k.config[a.map.id]||{}},exports:o[a.map.id]}}};U=function(a){this.events=V[a.id]||{};this.map=a;this.shim=k.shim[a.id];this.depExports=[];this.depMaps=[];this.depMatched=[];this.pluginMaps={};this.depCount=0};U.prototype={init:function(a,b,c,e){e=e||{};if(!this.inited){this.factory=b;if(c)this.on("error",c);else this.events.error&&(c=r(this,function(a){this.emit("error",a)}));this.depMaps=a&&a.slice(0);this.errback=c;this.inited=!0;this.ignore=e.ignore;e.enabled||this.enabled?this.enable():this.check()}},
defineDep:function(a,b){this.depMatched[a]||(this.depMatched[a]=!0,this.depCount-=1,this.depExports[a]=b)},fetch:function(){if(!this.fetched){this.fetched=!0;h.startTime=(new Date).getTime();var a=this.map;if(this.shim)h.makeRequire(this.map,{enableBuildCallback:!0})(this.shim.deps||[],r(this,function(){return a.prefix?this.callPlugin():this.load()}));else return a.prefix?this.callPlugin():this.load()}},load:function(){var a=this.map.url;Q[a]||(Q[a]=!0,h.load(this.map.id,a))},check:function(){if(this.enabled&&
!this.enabling){var a,b,c=this.map.id;b=this.depExports;var e=this.exports,m=this.factory;if(this.inited)if(this.error)this.emit("error",this.error);else{if(!this.defining){this.defining=!0;if(this.depCount<1&&!this.defined){if(D(m)){if(this.events.error)try{e=h.execCb(c,m,b,e)}catch(d){a=d}else e=h.execCb(c,m,b,e);if(this.map.isDefine)if((b=this.module)&&b.exports!==void 0&&b.exports!==this.exports)e=b.exports;else if(e===void 0&&this.usingExports)e=this.exports;if(a)return a.requireMap=this.map,
a.requireModules=[this.map.id],a.requireType="define",z(this.error=a)}else e=m;this.exports=e;if(this.map.isDefine&&!this.ignore&&(o[c]=e,g.onResourceLoad))g.onResourceLoad(h,this.map,this.depMaps);delete l[c];this.defined=!0}this.defining=!1;if(this.defined&&!this.defineEmitted)this.defineEmitted=!0,this.emit("defined",this.exports),this.defineEmitComplete=!0}}else this.fetch()}},callPlugin:function(){var a=this.map,b=a.id,d=j(a.prefix);this.depMaps.push(d);q(d,"defined",r(this,function(e){var m,
d;d=this.map.name;var x=this.map.parentMap?this.map.parentMap.name:null,i=h.makeRequire(a.parentMap,{enableBuildCallback:!0,skipMap:!0});if(this.map.unnormalized){if(e.normalize&&(d=e.normalize(d,function(a){return c(a,x,!0)})||""),e=j(a.prefix+"!"+d,this.map.parentMap),q(e,"defined",r(this,function(a){this.init([],function(){return a},null,{enabled:!0,ignore:!0})})),d=l[e.id]){this.depMaps.push(e);if(this.events.error)d.on("error",r(this,function(a){this.emit("error",a)}));d.enable()}}else m=r(this,
function(a){this.init([],function(){return a},null,{enabled:!0})}),m.error=r(this,function(a){this.inited=!0;this.error=a;a.requireModules=[b];A(l,function(a){a.map.id.indexOf(b+"_unnormalized")===0&&delete l[a.map.id]});z(a)}),m.fromText=r(this,function(b,e){var f=a.name,c=j(f),d=J;e&&(b=e);d&&(J=!1);n(c);try{g.exec(b)}catch(x){throw Error("fromText eval for "+f+" failed: "+x);}d&&(J=!0);this.depMaps.push(c);h.completeLoad(f);i([f],m)}),e.load(a.name,i,m,k)}));h.enable(d,this);this.pluginMaps[d.id]=
d},enable:function(){this.enabling=this.enabled=!0;t(this.depMaps,r(this,function(a,b){var c,e;if(typeof a==="string"){a=j(a,this.map.isDefine?this.map:this.map.parentMap,!1,!this.skipMap);this.depMaps[b]=a;if(c=L[a.id]){this.depExports[b]=c(this);return}this.depCount+=1;q(a,"defined",r(this,function(a){this.defineDep(b,a);this.check()}));this.errback&&q(a,"error",this.errback)}c=a.id;e=l[c];!L[c]&&e&&!e.enabled&&h.enable(a,this)}));A(this.pluginMaps,r(this,function(a){var b=l[a.id];b&&!b.enabled&&
h.enable(a,this)}));this.enabling=!1;this.check()},on:function(a,b){var c=this.events[a];c||(c=this.events[a]=[]);c.push(b)},emit:function(a,b){t(this.events[a],function(a){a(b)});a==="error"&&delete this.events[a]}};h={config:k,contextName:b,registry:l,defined:o,urlFetched:Q,defQueue:C,Module:U,makeModuleMap:j,nextTick:g.nextTick,configure:function(a){a.baseUrl&&a.baseUrl.charAt(a.baseUrl.length-1)!=="/"&&(a.baseUrl+="/");var b=k.pkgs,c=k.shim,e={paths:!0,config:!0,map:!0};A(a,function(a,b){e[b]?
b==="map"?O(k[b],a,!0,!0):O(k[b],a,!0):k[b]=a});if(a.shim)A(a.shim,function(a,b){E(a)&&(a={deps:a});if(a.exports&&!a.exportsFn)a.exportsFn=h.makeShimExports(a);c[b]=a}),k.shim=c;if(a.packages)t(a.packages,function(a){a=typeof a==="string"?{name:a}:a;b[a.name]={name:a.name,location:a.location||a.name,main:(a.main||"main").replace(ea,"").replace($,"")}}),k.pkgs=b;A(l,function(a,b){if(!a.inited&&!a.map.unnormalized)a.map=j(b)});if(a.deps||a.callback)h.require(a.deps||[],a.callback)},makeShimExports:function(a){return function(){var b;
a.init&&(b=a.init.apply(W,arguments));return b||X(a.exports)}},makeRequire:function(a,f){function d(e,c,i){var k,p;if(f.enableBuildCallback&&c&&D(c))c.__requireJsBuild=!0;if(typeof e==="string"){if(D(c))return z(G("requireargs","Invalid require call"),i);if(a&&L[e])return L[e](l[a.id]);if(g.get)return g.get(h,e,a);k=j(e,a,!1,!0);k=k.id;return!F.call(o,k)?z(G("notloaded",'Module name "'+k+'" has not been loaded yet for context: '+b+(a?"":". Use require([])"))):o[k]}I();h.nextTick(function(){I();p=
n(j(null,a));p.skipMap=f.skipMap;p.init(e,c,i,{enabled:!0});w()});return d}f=f||{};O(d,{isBrowser:v,toUrl:function(b){var d=b.lastIndexOf("."),f=null;d!==-1&&(f=b.substring(d,b.length),b=b.substring(0,d));return h.nameToUrl(c(b,a&&a.id,!0),f)},defined:function(b){b=j(b,a,!1,!0).id;return F.call(o,b)},specified:function(b){b=j(b,a,!1,!0).id;return F.call(o,b)||F.call(l,b)}});if(!a)d.undef=function(b){s();var c=j(b,a,!0),d=l[b];delete o[b];delete Q[c.url];delete V[b];if(d){if(d.events.defined)V[b]=
d.events;delete l[b]}};return d},enable:function(a){l[a.id]&&n(a).enable()},completeLoad:function(a){var b,c,d=k.shim[a]||{},g=d.exports;for(s();C.length;){c=C.shift();if(c[0]===null){c[0]=a;if(b)break;b=!0}else c[0]===a&&(b=!0);y(c)}c=l[a];if(!b&&!o[a]&&c&&!c.inited)if(k.enforceDefine&&(!g||!X(g)))if(p(a))return;else return z(G("nodefine","No define call for "+a,null,[a]));else y([a,d.deps||[],d.exportsFn]);w()},nameToUrl:function(a,b){var c,d,i,h,j,l;if(g.jsExtRegExp.test(a))h=a+(b||"");else{c=
k.paths;d=k.pkgs;h=a.split("/");for(j=h.length;j>0;j-=1)if(l=h.slice(0,j).join("/"),i=d[l],l=c[l]){E(l)&&(l=l[0]);h.splice(0,j,l);break}else if(i){c=a===i.name?i.location+"/"+i.main:i.location;h.splice(0,j,c);break}h=h.join("/");h+=b||(/\?/.test(h)?"":".js");h=(h.charAt(0)==="/"||h.match(/^[\w\+\.\-]+:/)?"":k.baseUrl)+h}return k.urlArgs?h+((h.indexOf("?")===-1?"?":"&")+k.urlArgs):h},load:function(a,b){g.load(h,a,b)},execCb:function(a,b,c,d){return b.apply(d,c)},onScriptLoad:function(a){if(a.type===
"load"||ga.test((a.currentTarget||a.srcElement).readyState))H=null,a=B(a),h.completeLoad(a.id)},onScriptError:function(a){var b=B(a);if(!p(b.id))return z(G("scripterror","Script error",a,[b.id]))}};h.require=h.makeRequire();return h}};g({});t(["toUrl","undef","defined","specified"],function(b){g[b]=function(){var c=w._;return c.require[b].apply(c,arguments)}});if(v&&(u=s.head=document.getElementsByTagName("head")[0],y=document.getElementsByTagName("base")[0]))u=s.head=y.parentNode;g.onError=function(b){throw b;
};g.load=function(b,c,d){var g=b&&b.config||{},i;if(v)return i=g.xhtml?document.createElementNS("http://www.w3.org/1999/xhtml","html:script"):document.createElement("script"),i.type=g.scriptType||"text/javascript",i.charset="utf-8",i.async=!0,i.setAttribute("data-requirecontext",b.contextName),i.setAttribute("data-requiremodule",c),i.attachEvent&&!(i.attachEvent.toString&&i.attachEvent.toString().indexOf("[native code")<0)&&!R?(J=!0,i.attachEvent("onreadystatechange",b.onScriptLoad)):(i.addEventListener("load",
b.onScriptLoad,!1),i.addEventListener("error",b.onScriptError,!1)),i.src=d,I=i,y?u.insertBefore(i,y):u.appendChild(i),I=null,i;else aa&&(importScripts(d),b.completeLoad(c))};v&&N(document.getElementsByTagName("script"),function(b){if(!u)u=b.parentNode;if(q=b.getAttribute("data-main")){if(!n.baseUrl)B=q.split("/"),Y=B.pop(),Z=B.length?B.join("/")+"/":"./",n.baseUrl=Z,q=Y;q=q.replace($,"");n.deps=n.deps?n.deps.concat(q):[q];return!0}});define=function(b,c,d){var g,i;typeof b!=="string"&&(d=c,c=b,b=
null);E(c)||(d=c,c=[]);!c.length&&D(d)&&d.length&&(d.toString().replace(ca,"").replace(da,function(b,d){c.push(d)}),c=(d.length===1?["require"]:["require","exports","module"]).concat(c));if(J&&(g=I||ba()))b||(b=g.getAttribute("data-requiremodule")),i=w[g.getAttribute("data-requirecontext")];(i?i.defQueue:P).push([b,c,d])};define.amd={jQuery:!0};g.exec=function(b){return eval(b)};g(n)}})(this);

define("lib/require", function(){});

require.config({
    paths: {
        jquery: "//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min",
        webfont: "//ajax.googleapis.com/ajax/libs/webfont/1/webfont",
        iframeapi: "//secure.api.viewer.zmags.com/widgets/iframe"
    },
    shim: {
        webfont: {
            exports: "WebFont"
        }
    }
});
define("require.config.js", function(){});

/*global window*/
define('util/QueryParameters',[],
    function () {
        

        /**
         * Query parameter parsing.
         * The parameters are placed directly as properties on the object.
         *
         * @author Bo Gotthardt
         * @constructor
         *
         * @param {Window} [frame] The window to parse query parameters for. Optional, defaults to the current frame.
         */
        function QueryParameters(frame) {
            frame = frame || window;
            var scope = this,
                queryString = frame.location.search;

            if (queryString !== "") {
                var parameters = queryString.substr(1).split("&");
                parameters.forEach(function (parameter) {
                    var keyValue = parameter.split("=");
                    if (keyValue.length === 2) {
                        scope[keyValue[0]] = decodeURIComponent(keyValue[1]);
                    } else {
                        scope[keyValue[0]] = "";
                    }
                });
            }
        }

        /**
         * Returns the query parameters as a string, including the leading ? if applicable.
         * If the parameters happen to have a "toQueryString" key, you need to use QueryParameters.prototype.toQueryString.call(x) instead.
         *
         * @returns {String}
         */
        QueryParameters.prototype.toQueryString = function () {
            var keys = Object.prototype.keys.call(this);

            if (keys.length === 0) {
                return "";
            }

            return "?" + keys.map(function (key) {
                return key + "=" + this[key];
            }).join("&");
        };

        return QueryParameters;
    });
/*!
 * LucidJS
 *
 * Lucid is an easy to use event emitter library. LucidJS allows you to create your own event system and even pipe in
 * events from one emitter to another.
 *
 * Copyright 2012, Robert William Hurst
 * Licenced under the BSD License.
 * See https://raw.github.com/RobertWHurst/LucidJS/master/license.txt
 */
(function(factory) {

	//AMD
	if(typeof define === 'function' && define.amd) {
		define('lib/lucid',factory);

	//NODE
	} else if((typeof module == 'object' || typeof module == 'function') && module.exports) {
		module.exports = factory();

	//GLOBAL
	} else {
		window.LucidJS = factory();
	}

})(function() {
	var api;

	//return the api
	api = {
		"emitter": EventEmitter
	};

	//indexOf pollyfill
	[].indexOf||(Array.prototype.indexOf=function(a,b,c){for(c=this.length,b=(c+~~b)%c;b<c&&(!(b in this)||this[b]!==a);b++);return b^c?b:-1;});

	return api;

	/**
	 * Creates a event emitter.
	 */
	function EventEmitter(object) {
		var emitter = object || {}, listeners = {}, setEvents = {}, pipes = [];

		//augment an object if it isn't already an emitter
		if(
			!emitter.on &&
			!emitter.once &&
			!emitter.trigger &&
			!emitter.set &&
			!emitter.pipe &&
			!emitter.listeners
		) {
			emitter.on = on;
			emitter.off = off;
			emitter.once = once;
			emitter.trigger = trigger;
			emitter.set = set;
			emitter.set.clear = clearSet;
			emitter.pipe = pipe;
			emitter.pipe.clear = clearPipes;
			emitter.listeners = getListeners;
			emitter.listeners.clear = clearListeners;
		} else {
			return emitter;
		}

		if(emitter.addEventListener || emitter.attachEvent) {
			handleNode(emitter);
		}

		return emitter;

		/**
		 * Binds listeners to events.
		 * @param event
		 * @return {Object}
		 */
		function on(event     ) {
			var args, binding = {}, aI, sI;
			args = Array.prototype.slice.apply(arguments, [1]);

			//recurse over a batch of events
			if(typeof event === 'object' && typeof event.push === 'function') { return batchOn(event, args); }

			//trigger the listener event
			if(event.slice(0, 7) !== 'emitter' && (listeners['emitter'] || listeners['emitter.listener'])) {
				for(aI = 0; aI < args.length; aI += 1) {
					trigger('emitter.listener', event, args[aI]);
				}
			}

			//create the event
			if(!listeners[event]) { listeners[event] = []; }

			//add each callback
			for(aI = 0; aI < args.length; aI += 1) {
				if(typeof args[aI] !== 'function') { throw new Error('Cannot bind event. All callbacks must be functions.'); }
				listeners[event].push(args[aI]);
			}

			binding.clear = clear;

			return binding;

			function clear() {
				if(!listeners[event]) { return; }
				for(aI = 0; aI < args.length; aI += 1) {
					listeners[event].splice(listeners[event].indexOf(args[aI]), 1);
				}
				if(listeners[event].length < 1) { delete listeners[event]; }
			}

			function batchOn(events, args) {
				var eI, binding = {}, bindings = [];
				for(eI = 0; eI < events.length; eI += 1) {
					args.unshift(events[eI]);
					bindings.push(on.apply(this, args));
					args.shift();
				}

				binding.clear = clear;

				return binding;

				function clear() {
					var bI;
					for(bI = 0; bI < bindings.length; bI += 1) {
						bindings[bI].clear();
					}
				}
			}
		}

		/**
		 * Unbinds listeners to events.
		 * @param event
		 * @return {Object}
		 */
		function off(event     ) {
			var args = Array.prototype.slice.apply(arguments, [1]), aI, sI;

			//recurse over a batch of events
			if(typeof event === 'object' && typeof event.push === 'function') {
				for(sI = 0; sI < event.length; sI += 1) {
					off.apply(null, [event[sI]].concat(args));
				}
				return;
			}

			if(!listeners[event]) { throw new Error('Tried to remove an event from a non-existant event of type "'+event+'".'); }

			//remove each callback
			for(aI = 0; aI < args.length; aI += 1) {
				if(typeof args[aI] !== 'function') { throw new Error('Tried to remove a non-function.'); }
				var listenerIndex = listeners[event].indexOf(args[aI]);
				listeners[event].splice(listenerIndex, 1);
			}
		}

		/**
		 * Binds listeners to events. Once an event is fired the binding is cleared automatically.
		 * @param event
		 * @return {Object}
		 */
		function once(event     ) {
			var binding, args = Array.prototype.slice.apply(arguments, [1]), result = true, cleared = false;

			binding = on(event, function(    ) {
				var aI, eventArgs = Array.prototype.slice.apply(arguments);

				if(!binding) {
					if(cleared) { return; }
					cleared = true;
					setTimeout(function(){ binding.clear(); }, 0);
				} else {
					binding.clear();
				}

				for(aI = 0; aI < args.length; aI += 1) {
					if(args[aI].apply(this, eventArgs) === false) {
						result = false;
					}
				}

				return result;
			});

			return binding;
		}

		/**
		 * Triggers events. Passes listeners any additional arguments.
		 *  Optimized for 6 arguments.
		 * @param event
		 * @return {Boolean}
		 */
		function trigger(event, a1, a2, a3, a4, a5, a6, a7, a8, a9, la) {
			var longArgs, lI, eventListeners, result = true;

			if(typeof la !== 'undefined') {
				longArgs = Array.prototype.slice.apply(arguments, [1]);
			}

			if(typeof event === 'object' && typeof event.push === 'function') {
				if(longArgs) {
					return batchTrigger.apply(null, arguments);
				} else {
					return batchTrigger(event, a1, a2, a3, a4, a5, a6, a7, a8, a9);
				}
			}

			event = event.split('.');
			while(event.length) {
				eventListeners = listeners[event.join('.')];

				if(event[0] !== 'emitter' && (listeners['emitter'] || listeners['emitter.event'])) {
					if(longArgs) {
						trigger.apply(this, [].concat('emitter.event', event.join('.'), longArgs));
					} else {
						trigger('emitter.event', event.join('.'), a1, a2, a3, a4, a5, a6, a7, a8, a9);
					}
				}

				if(eventListeners) {
					eventListeners = [].concat(eventListeners);
					for(lI = 0; lI < eventListeners.length; lI += 1) {
						if(longArgs) {
							if(eventListeners[lI].apply(this, longArgs) === false) {
								result = false;
							}
						} else {
							if(eventListeners[lI](a1, a2, a3, a4, a5, a6, a7, a8, a9) === false) {
								result = false;
							}
						}
					}
				}
				event.pop();
			}

			return result;
		}

		/**
		 * Triggers a batch of events. Passes listeners any additional arguments.
		 *  Optimized for 6 arguments.
		 */
		function batchTrigger(events, a1, a2, a3, a4, a5, a6, a7, a8, a9, la) {
			var longArgs, eI, result = true;

			if(typeof la !== 'undefined') {
				longArgs = Array.prototype.slice.apply(arguments, [1]);
			}

			for(eI = 0; eI < events.length; eI += 1) {
				if(longArgs) {
					args.unshift(events[eI]);
					if(trigger.apply(this, args) === false) { result = false; }
					args.shift();
				} else {
					if(trigger(events[eI], a1, a2, a3, a4, a5, a6, a7, a8, a9) === false) { result = false; }
				}

			}
			return result;
		}

		/**
		 * Sets events. Passes listeners any additional arguments.
		 *  Optimized for 6 arguments.
		 */
		function set(event, a1, a2, a3, a4, a5, a6, a7, a8, a9, la) {
			var args, binding, _clear;

			if(la) { args = Array.prototype.slice.apply(arguments, [1]); }

			if(typeof event === 'object' && event.push) {
				if(args) { return batchSet.apply(null, args); }
				else { return batchSet(event, a1, a2, a3, a4, a5, a6, a7, a8, a9); }
			}

			binding = on(['emitter.listener', 'pipe.listener'], function(_event, listener) {
				var lI;

				if(event === _event) {
					if(args) { listener.apply(null, args); }
					else { listener(a1, a2, a3, a4, a5, a6, a7, a8, a9); }
				}
			});

			if(args) { trigger.apply(null, arguments); }
			else { trigger(event, a1, a2, a3, a4, a5, a6, a7, a8, a9); }

			if(!setEvents[event]) { setEvents[event] = []; }
			setEvents[event].push(binding);

			_clear = binding.clear;
			binding.clear = clear;

			return binding;

			function clear() {
				trigger('emitter.unset', event);
				setEvents[event].splice(setEvents[event].indexOf(binding), 1);
				_clear();
			}
		}

		function batchSet(events, a1, a2, a3, a4, a5, a6, a7, a8, a9, la) {
			var binding = {}, args, eI, bindings = [];

			if(la) { args = Array.prototype.slice.apply(arguments, [1]); }

			for(eI = 0; eI < events.length; eI += 1) {
				if(args) {
					bindings.push(set.apply(null, [events[eI]].concat(args)));
				} else {
					bindings.push(set(events[eI], a1, a2, a3, a4, a5, a6, a7, a8, a9));
				}
			}

			binding.clear = clear;
			return binding;

			function clear() {
				var bI;
				for(bI = 0; bI < bindings.length; bI += 1) {
					bindings[bI].clear();
				}
			}
		}

		/**
		 * Clears a set event, or all set events.
		 * @param event
		 */
		function clearSet(event) {
			var bI;
			if(event) {
				for(bI = 0; bI < setEvents[event].length; bI += 1) {
					setEvents[event][bI].clear();
				}
				delete setEvents[event];
			} else {
				for(event in setEvents) {
					if(!setEvents.hasOwnProperty(event)) { continue; }
					clearSet(event);
				}
			}
		}

		/**
		 * Pipes events from another emitter.
		 * @param event [optional]
		 * @return {Object}
		 */
		function pipe(event    ) {
			var binding = {}, emitters, eI, emitter, bindings = [],
			setEvents = [], eventCaptures = [], sendListeners = [];

			emitters = Array.prototype.slice.apply(arguments, [1]);

			if(typeof event === 'object') {
				if(event.on) { emitters.unshift(event); event = false; }
				else { return batchPipe.apply(null, arguments); }
			}

			for(eI = 0; eI < emitters.length; eI += 1) {
				emitter = emitters[eI];
				eventCaptures.push(emitter.on('emitter.event', captureEvent));
				sendListeners.push(on('emitter.listener', sendListener));
			}

			binding.clear = clear;
			return binding;

			function captureEvent(event     ) {
				var setEvent = false, args;
				args = Array.prototype.slice.apply(arguments, [1]);
				emitter.once(event, function() { setEvent = true; });
				if(event.substr(0, 4) !== 'pipe' && (listeners['pipe'] || listeners['pipe.event'])) {
					trigger('pipe.event', event, args);
				}
				if(setEvent) { setEvents.push(set.apply(null, [event].concat(args))); }
				else { trigger.apply(null, [event].concat(args)); }
			}

			function sendListener(event, listener) {
				emitter.trigger('pipe.listener', event, listener);
			}

			function clear() {
				var bI, sI, eI, sII;
				for(bI = 0; bI < bindings.length; bI += 1) {
					bindings[bI].clear();
				}
				for(sI = 0; sI < bindings.length; sI += 1) {
					setEvents[sI].clear();
				}
				for(eI = 0; eI < eventListeners.length; eI += 1) {
					bindings[eI].clear();
				}
				for(sII = 0; sII < sendListeners.length; sII += 1) {
					setEvents[sII].clear();
				}
			}
		}

		function batchPipe(events    ) {
			var binding = {}, eI, bindings = [], emitters;
			emitters = Array.prototype.slice.apply(arguments, [1]);
			for(eI = 0; eI < events.length; eI += 1) {
				bindings.push(pipe.apply(null, [events[eI]].concat(emitters)));
			}

			binding.clear = clear;
			return binding;

			function clear() {
				var bI;
				for(bI = 0; bI < bindings.length; bI += 1) {
					bindings[bI].clear();
				}
			}
		}

		/**
		 * Clears pipes based on the events they transport.
		 * @param event
		 */
		function clearPipes(event) {
			var pI, bI, binding;

			for(pI = 0; pI < pipes.length; pI += 1) {
				if(event) {
					if(pipes[pI].type === 2) { continue; }
					if(pipes[pI].events.indexOf(event) === -1) { continue; }
					pipes[pI].events.splice(pipes[pI].events.indexOf(event), 1);
				}
				if(pipes[pI].type === 2) { pipes[pI].listenerBinding.clear(); }
				for(bI = 0; bI < pipes[pI].bindings.length; bI += 1) {
					if(event && pipes[pI].bindings[bI].event !== event) { continue; }
					pipes[pI].bindings[bI].clear();
					pipes[pI].bindings.splice(bI, 1);
					bI -= 1;
				}
				if(pipes[pI].bindings.length < 1) {
					pipes.splice(pI, 1);
					pI -= 1;
				}
			}
		}

		/**
		 * Gets listeners for events.
		 * @param event
		 * @return {*}
		 */
		function getListeners(event) {
			if(event) {
				return listeners[event];
			} else {
				return listeners;
			}
		}

		/**
		 * Clears listeners by events.
		 * @param event
		 */
		function clearListeners(event) {
			if(event) {
				delete listeners[event];
			} else {
				listeners = {};
			}
		}

		/**
		 * Clears the emitter
		 */
		function clear() {

			if(listeners['emitter'] || listeners['emitter.clear']) {
				trigger('emitter.clear');
			}

			listeners = {};

			clearSet();
			clearPipes();

			delete emitter.on;
			delete emitter.once;
			delete emitter.trigger;
			delete emitter.set;
			delete emitter.pipe;
			delete emitter.listeners;
			delete emitter.clear;
		}

		/**
		 * Binds the emitter's event system to the DOM event system
		 * @param node
		 */
		function handleNode(node) {
			var handledEvents = [], listenerBinding, DOMEventListeners = [];

			listenerBinding = on('emitter.listener', function(event) {
				if(handledEvents.indexOf(event) > -1) { return; }
				handledEvents.push(event);

				try {

					//W3C
					if(node.addEventListener) {
						node.addEventListener(event, nodeListener, false);
						DOMEventListeners.push({
							"event": event,
							"listener": nodeListener
						});
					}

					//MICROSOFT
					else if(node.attachEvent) {
						node.attachEvent('on' + event, nodeListener);
						DOMEventListeners.push({
							"event": event,
							"listener": nodeListener
						});
					}

				} catch(e) {
					console.error(e);
				}

				function nodeListener(eventObj    ) {
					var args = Array.prototype.slice.apply(arguments);
					args.unshift([event, 'dom.' + event]);
					if(trigger.apply(this, args) === false) {
						eventObj.preventDefault();
						eventObj.stopPropagation();
					}
				}
			});

			emitter.clearNodeEmitter = clearNodeEmitter;

			function clearNodeEmitter() {
				var DI;
				for(DI = 0; DI < DOMEventListeners.length; DI += 1) {
					try {

						//W3C
						if(node.removeEventListener) {
							node.removeEventListener(DOMEventListeners[DI].event, DOMEventListeners[DI].listener, false);
						}

						//MICROSOFT
						else if(node.detachEvent) {
							node.detachEvent('on' + DOMEventListeners[DI].event, DOMEventListeners[DI].listener);
						}

					} catch(e) {
						console.error(e);
					}
				}

				handledEvents = [];
				listenerBinding.clear();
			}
		}
	}
});

/*global window*/
define('widget/BaseWidget',["jquery", "util/QueryParameters", "lib/lucid", "iframeapi"],
    function ($, QueryParameters, LucidJS, Iframe) {
        

        /**
         * Generic base functionality for widgets.
         *
         * @event activate When the widget is potentially visible to the user.
         * @event deactivate When the widget is no longer visible to the user.
         * @event resize When the window is resized.
         * @event unload When the window is about to be destroyed.
         *
         * @author Bo Gotthardt
         * @constructor
         *
         * @param {Object} options
         */
        function BaseWidget(options) {
            var scope = this;
            this.options = options;

            this.element = $("<div class='BaseWidget'></div>")
                .appendTo("body");

            /**
             * Whether the widget is currently active.
             * @type {Boolean}
             */
            this.active = false;

            /**
             * A promise for the widget having finished initializing.
             * Subclasses must resolve this when they are done initializing.
             * @type {$.Deferred}
             */
            this.initialized = new $.Deferred();

            Iframe.addEventListener(Iframe.IFRAME_WIDGET_ACTIVATE, function (event) {
                scope.activate(event);
            });

            Iframe.addEventListener(Iframe.IFRAME_WIDGET_DEACTIVATE, function (event) {
                scope.deactivate(event);
            });

            $(window).on("resize", function () {
                scope.trigger("resize");
            });

            $(window).on("beforeunload", function () {
                scope.trigger("unload");
            });
        }

        // Mix-in event handling functionality.
        LucidJS.emitter(BaseWidget.prototype);

        /**
         * Activate the widget. Is called automatically by the Iframe API.
         * @param event
         */
        BaseWidget.prototype.activate = function (event) {
            this.active = true;
            this.trigger("activate", event);
        };

        /**
         * Deactivate the widget. Is called automatically by the Iframe API.
         * @param event
         */
        BaseWidget.prototype.deactivate = function (event) {
            this.active = false;
            this.trigger("deactivate", event);
        };

        /**
         * Make the widget visible.
         */
        BaseWidget.prototype.show = function () {
            this.element.toggleClass("hidden", false);
        };

        /**
         * Hide the widget.
         */
        BaseWidget.prototype.hide = function () {
            this.element.toggleClass("hidden", true);
        };

        return BaseWidget;
    });
define('util/Promise',["jquery"],
    function ($) {
        

        /**
         * Utility class for Promises/Deferreds. Also defines the Promise class to stop IntelliJ warning about it not being found.
         *
         * The actual Promise/Deferred class is from jQuery, see <a href="http://api.jquery.com/category/deferred-object/">jQuery Deferred documentation</a>.
         *
         * @author Bo Gotthardt
         * @constructor
         */
        function Promise() {}

        /**
         * See <a href="http://api.jquery.com/deferred.then/">deferred.then()</a>.
         *
         * @param {Function} doneFilter
         * @param {Function} [failFilter]
         * @param {Function} [progressFilter]
         */
        Promise.prototype.then = function (doneFilter, failFilter, progressFilter) {};
        /**
         * See <a href="http://api.jquery.com/deferred.done/">deferred.done()</a>.
         *
         * @param {Function} callback
         */
        Promise.prototype.done = function (callback) {};
        /**
         * See <a href="http://api.jquery.com/deferred.fail/">deferred.fail()</a>.
         *
         * @param {Function} callback
         */
        Promise.prototype.fail = function (callback) {};
        /**
         * See <a href="http://api.jquery.com/deferred.progress/">deferred.progress()</a>.
         *
         * @param {Function} callback
         */
        Promise.prototype.progress = function (callback) {};

        // TODO Fix these to work with any number of arguments.
        // There seems to be a problem with new $.Deferred().reject.apply() returning window.
        /**
         * Create a rejected promise.
         *
         * @static
         *
         * @param {*} [arg]
         * @return {Promise}
         */
        Promise.rejected = function (arg) {
            return new $.Deferred().reject(arg).promise();
        };

        /**
         * Create a resolved promise.
         *
         * @static
         *
         * @param {*} [arg]
         * @return {Promise}
         */
        Promise.resolved = function (arg) {
            return new $.Deferred().resolve(arg).promise();
        };


        function notification(subordinates, combinedDeferred) {
            var numDone = 0;

            subordinates.forEach(function (subordinate) {
                // The subordinates can be both promises and already computed synchronous values.
                // This is the same check as in $.when().
                if (Promise.isPromise(subordinate)) {
                    subordinate.done(function (arg) {
                        numDone++;
                        combinedDeferred.notify.call(this, arg, numDone / subordinates.length);
                    });
                } else {
                    numDone++;
                    combinedDeferred.notify.call(this, subordinate, numDone / subordinates.length);
                }
            });
        }

        /**
         * An improved version of $.when() that returns the values as a single list.
         *
         * Also progresses when individual subordinates are done. The progress event will have the resolved Promise's
         * value and the percentage of subordinates that are done as parameters.
         *
         * Note that due to the way progress() behaves, this function has a rather subtle gotcha when one or more of
         * the subordinates are done already (i.e. non-Promises or already resolved Promises).
         * These will then trigger the progress events <b>synchronously</b> while inside this function call. And unlike
         * done() and fail(), progress() handlers attached later are not called with previously triggered events.
         * So it is therefore not guaranteed how many progress events the caller will actually get, unless they create
         * their own deferred, set up a progress handler and only then pass it as the combinedDeferred parameter.
         *
         * @static
         *
         * @param {*[]} subordinates The list of subordinates, either Promises or arbitrary values.
         * @param {Deferred} [combinedDeferred] The "combined" deferred (not Promise) to use, instead of creating it internally.
         * @return {Promise} A promise for the list of the values of all the subordinates.
         *                   The promise interface of combinedDeferred if that was passed.
         */
        Promise.all = function (subordinates, combinedDeferred) {
            // We would like the returned promise to progress whenever an individual promise has resolved, but $.when() does not support that.
            // So we have to create our own deferred that can be resolved by $.when(), and progressed by done() from the individual promises.
            combinedDeferred = combinedDeferred || new $.Deferred();
            var numDone = 0;

            subordinates.forEach(function (subordinate) {
                // The subordinates can be both promises and already computed synchronous values.
                // This is the same check as in $.when().
                if (Promise.isPromise(subordinate)) {
                    subordinate.done(function (arg) {
                        numDone++;
                        combinedDeferred.notify.call(this, arg, numDone / subordinates.length);
                    });
                } else {
                    numDone++;
                    combinedDeferred.notify.call(this, subordinate, numDone / subordinates.length);
                }
            });

            $.when.apply(this, subordinates)
                .done(function () {
                    // Return the subordinates' values as one list, instead of as individual arguments.
                    combinedDeferred.resolve($.makeArray(arguments));
                })
                .fail(combinedDeferred.reject);

            return combinedDeferred.promise();
        };

        /**
         * Alternative version of $.when() that always resolves with a list of the return vales of the subordinates that resolved.
         *
         * Also progresses when individual subordinates are done. The progress event will have the resolved Promise's
         * value and the percentage of subordinates that are done as parameters.
         *
         * See Promise.all() for a note on how the progress events work.
         *
         * @static
         *
         * @param {*[]} subordinates The list of subordinates, either Promises or arbitrary values.
         * @param {Deferred} [combinedDeferred] The "combined" deferred (not Promise) to use, instead of creating it internally.
         * @return {Promise} A promise for a list of the values of the subordinates that resolved.
         */
        Promise.any = function (subordinates, combinedDeferred) {
            combinedDeferred = combinedDeferred || new $.Deferred();
            var numDone = 0;

            // Set up these first so we do not notify on
            subordinates.forEach(function (subordinate) {
                // The subordinates can be both promises and already computed synchronous values.
                // This is the same check as in $.when().
                if (Promise.isPromise(subordinate)) {
                    subordinate.done(function (arg) {
                        numDone++;
                        combinedDeferred.notify.call(this, arg, numDone / subordinates.length);
                    });
                } else {
                    numDone++;
                    combinedDeferred.notify.call(this, subordinate, numDone / subordinates.length);
                }
            });

            subordinates = subordinates.map(function (subordinate) {
                if (Promise.isPromise(subordinate)) {
                    // Always resolve subordinates rather than reject so the when() deferred always resolves.
                    return subordinate.then(null, function () {
                        numDone++;
                        return Promise.resolved();
                    });
                }
                return subordinate;
            });

            $.when.apply(this, subordinates)
                .done(function () {
                    // Return the subordinates as one list, instead of as individual arguments.
                    combinedDeferred.resolve(Array.prototype.filter.call(arguments, function (item) {
                        // Filter out empty values caused by the resolution above.
                        return item !== undefined;
                    }));
                });

            return combinedDeferred.promise();
        };

        /**
         * Determine whether the specified argument is a Promise.
         *
         * @static
         *
         * @param {*} possiblePromise
         * @return {Boolean}
         */
        Promise.isPromise = function (possiblePromise) {
            // This is how jQuery#when() does it internally.
            return $.isFunction(possiblePromise.promise);
        };

        return Promise;
    });
/*global window*/
define('util/Logger',["util/Promise"],
    function (Promise) {
        

        var output;

        // Create a dummy console for IE.
        if (window.console !== undefined) {
            output = window.console;
        } else {
            output = {
                info: function () {},
                warn: function () {},
                error: function () {}
            };
        }

        /**
         * A simple instantiable logger.
         *
         * @author Bo Gotthardt
         * @constructor
         *
         * @param {String} name The logger name.
         */
        function Logger(name) {
            this._name = name;
        }

        /**
         * Use the specified console function name to print the list of data.
         *
         * @private
         *
         * @param {String} functionName
         * @param {Arguments/ *[]} dataList
         */
        Logger.prototype._callPrintFunction = function (functionName, dataList) {
            var messages = ["[" + this._name + "]"].concat(Array.prototype.slice.call(dataList));

            // IE doesn't inherit the logging functions from Function. This also means that ES5-shim's bind() doesn't work on it.
            if (typeof output[functionName] !== "function") {
                output[functionName](messages.join(" "));
            } else {
                // Chrome requires the console as it's own context.
                output[functionName].apply(output, messages);
            }
        };

        /**
         * Print the list of data to the console.
         * If there is only one argument and it is a Promise, it's resolved value will be logged instead.
         *
         * @private
         *
         * @param {String} functionName
         * @param {Arguments} dataList
         */
        Logger.prototype._print = function (functionName, dataList) {
            var scope = this;
            if (Promise.isPromise(dataList[0]) && dataList.length === 1) {
                dataList[0]
                    .done(function () {
                        scope._callPrintFunction(functionName, arguments);
                    })
                    .fail(function () {
                        scope._callPrintFunction(functionName, ["Promise failed."]);
                    });
            } else {
                scope._callPrintFunction(functionName, dataList);
            }
        };

        /**
         * Log informational message.
         */
        Logger.prototype.info = function () {
            this._print("info", arguments);
        };

        /**
         * Log warning about undesired behavior.
         */
        Logger.prototype.warn = function () {
            this._print("warn", arguments);
        };

        /**
         * Log error message.
         */
        Logger.prototype.error = function () {
            this._print("error", arguments);
        };

        /**
         * Assert that the specified condition is true. If it is not, any additional arguments will be logged as an
         * error and the browser debugger will be triggered.
         *
         * @param {*} condition The condition to check
         */
        Logger.prototype.assert = function (condition) {
            if (!condition) {
                this.error.apply(this, Array.prototype.slice.call(arguments, 1));
                // This debugger statement is allowed to stay in as it's part of the assert functionality.
                /*jslint debug:true*/
                debugger;
            }
        };

        return Logger;
    });
/*global window*/
define('util/Browser',["jquery", "util/Logger"],
    function ($, Logger) {
        
        var log = new Logger("Browser");

        function findCSSPrefix() {
            var style = window.getComputedStyle($("body")[0], null);

            if (style.WebkitTransition !== undefined) {
                return "-webkit-";
            }
            if (style.MozTransition !== undefined) {
                return "-moz-";
            }
            if (style.msTransition !== undefined) {
                return "-ms-";
            }
            if (style.OTransition !== undefined) {
                return "-o-";
            }
            log.error("Unable to determine browser CSS prefix.");
            return "";
        }

        var prefix = findCSSPrefix();

        /**
         * Utility class for getting the window object.
         * This makes unit testing easier and avoids having to add it as an allowed global variable.
         *
         * @author Bo Gotthardt
         * @constructor
         */
        function Browser() {}

        /**
         * Get the window object.
         *
         * @static
         *
         * @return {Window}
         */
        Browser.getWindow = function () {
            return window;
        };

        /**
         * Whether the current page is loaded over HTTPS.
         *
         * @static
         *
         * @return {Boolean}
         */
        Browser.isSecure = function () {
            return window.location.protocol === "https:";
        };

        /**
         * Get the CSS vendor prefix used by this browser.
         *
         * @static
         *
         * @return {String}
         */
        Browser.getCSSPrefix = function () {
            return prefix;
        };

        return Browser;
    });
/*global setTimeout, window */
define('widget/AnimatedWidget',["jquery", "widget/BaseWidget", "util/Browser"],
    function ($, BaseWidget, Browser) {
        

        /**
         * Widget that slides in from offscreen, ending next to the opposite edge.
         * 
         * Uses translate3d to take advantage of hardware acceleration.
         *
         * @author Bo Gotthardt
         * @constructor
         *
         * @param {Object} options
         */
        function AnimatedWidget(options) {
            BaseWidget.call(this, options);

            this.element.addClass("AnimatedWidget");

            var from = this.options.from;
            if (from) {
                this.hide();

                var scope = this;

                this.on("activate", function () {
                    scope.initialized.done(function () {
                        scope._positionOutsideFrame();
                        scope.show();
                        scope._animateToOppositeEdge(scope.options.duration,
                                                     scope.options.timingFunction,
                                                     scope.options.delay);
                    });
                });

                this.on("deactivate", function () {
                    scope.hide();
                });

                this.on("resize", function () {
                    if (scope.active) {
                        // Reset the animation target position.
                        scope._animateToOppositeEdge("0", "ease", "0");
                    }
                });
            }
        }
        AnimatedWidget.prototype = Object.create(BaseWidget.prototype);

        /**
         * Position the widget just offscreen so it is ready to slide in.
         * 
         * @private
         */
        AnimatedWidget.prototype._positionOutsideFrame = function () {
            var x = 0,
                y = 0;

            switch (this.options.from) {
            case "top":
                y = -this.element.height();
                break;
            case "bottom":
                y = $(window).height();
                break;
            case "left":
                x = -this.element.width();
                break;
            case "right":
                x = $(window).width();
                break;
            }

            this.element.css({
                transition: "none",
                transform: "translate3d(" + x + "px, " + y + "px, 0)"
            });
        };

        /**
         * Animate the widget moving to the opposite edge of the window.
         *
         * @param {String} [duration=1s] The animation duration as a CSS string, e.g. "1s".
         * @param {String} [timingFunction=ease] The animation timing function as a CSS string, e.g. "ease".
         * @param {String} [delay=0] The animation start delay as a CSS string, e.g. "1s".
         * @private
         */
        AnimatedWidget.prototype._animateToOppositeEdge = function (duration, timingFunction, delay) {
            duration = duration || "1s";
            timingFunction = timingFunction || "ease";
            delay = delay || "500ms";

            var x = 0,
                y = 0;

            switch (this.options.from) {
            case "top":
                y = $(window).height() - this.element.height();
                break;
            case "left":
                x = $(window).width() - this.element.width();
                break;
            // Right and bottom both just reset to 0.
            }

            var scope = this;
            setTimeout(function () {
                scope.element.css({
                    transition: Browser.getCSSPrefix() + "transform " + duration + " " + timingFunction + " " + delay,
                    transform: "translate3d(" + x + "px, " + y + "px, 0)"
                });
            }, 0);
        };

        return AnimatedWidget;
    });
define('util/WebFontLoader',["jquery", "webfont"],
    function ($, WebFont) {
        

        function load(config) {
            var deferred = new $.Deferred();

            config.active = function () {
                deferred.resolve();
            };
            config.inactive = function () {
                deferred.reject();
            };

            WebFont.load(config);

            return deferred.promise();
        }


        /**
         * Utility class for loading web fonts.
         *
         * @author Bo Gotthardt
         *
         * @constructor
         */
        function WebFontLoader() {
        }

        WebFontLoader.loadGoogle = function () {
            return load({
                google: {
                    families: arguments
                }
            });
        };

        WebFontLoader.loadTypekit = function (id) {
            return load({
                typekit: {
                    id: id
                }
            });
        };

        WebFontLoader.loadFontAwesome = function () {
            var deferred = new $.Deferred();

            $("<link href='//netdna.bootstrapcdn.com/font-awesome/3.0.2/css/font-awesome.css' rel='stylesheet'>")
                .on("load", function () {
                    deferred.resolve();
                })
                .appendTo("head");

            return deferred;
        };

        return WebFontLoader;
    });
/*global window*/
define('widget/TextWidget',["jquery", "widget/AnimatedWidget", "util/WebFontLoader", "util/Logger", "util/Promise"],
    function ($, AnimatedWidget, WebFontLoader, Logger, Promise) {
        
        var log = new Logger("TextWidget");

        /**
         * Widget for displaying text.
         * Automatically sized to match the widow size.
         *
         * @author Bo Gotthardt
         * @constructor
         *
         * @param {Object} options
         */
        function TextWidget(options) {
            AnimatedWidget.call(this, options);

            var scope = this;

            ["font-family", "color", "text-shadow", "opacity", "letter-spacing", "line-height"].forEach(function (property) {
                if (scope.options[property]) {
                    scope.element.css(property, scope.options[property]);
                }
            });

            var text = this.options.text.replace("\n", "<br/>");
            this.element.html(text)
                .addClass("TextWidget");

            var clazz = this.options["class"];
            if (clazz) {
                this.element.addClass(clazz);
            }

            this.on("resize", function () {
                scope._matchTextSizeToWindow();
            });

            this._loadFonts().then(this.initialized.resolve, this.initialized.reject);
        }
        TextWidget.prototype = Object.create(AnimatedWidget.prototype);

        /**
         * Load any external fonts required.
         *
         * @returns {Promise} A promise for all the fonts having loaded.
         * @private
         */
        TextWidget.prototype._loadFonts = function () {
            var scope = this,
                waitingOnFonts = [];

            if (this.options.googleFont) {
                var fontName = this.options["font-family"];
                waitingOnFonts.push(WebFontLoader.loadGoogle(fontName));
            }

            if (this.options.fontAwesome) {
                waitingOnFonts.push(WebFontLoader.loadFontAwesome());
            }

            if (this.options.typekitId) {
                waitingOnFonts.push(WebFontLoader.loadTypekit(this.options.typekitId));
            }

            return Promise.all(waitingOnFonts)
                .then(function () {
                    scope._matchTextSizeToWindow();
                });
        };

        /**
         * Resize the text so it fills the window.
         * @private
         */
        TextWidget.prototype._matchTextSizeToWindow = function () {
            var win = $(window);
            // There's no way to scale some text to fit in a box with CSS.
            // But we can keep increasing the font size until the element is larger than the window.
            var size = 6;
            while (this.element.width() < win.width() &&
                    this.element.height() < win.height() &&
                    size < 10000) {
                this.setFontSize(++size);
            }
            this.setFontSize(size - 1);
        };

        /**
         * Set the font size, as a number of pixels.
         * @param {Number} size
         */
        TextWidget.prototype.setFontSize = function (size) {
            this.element.css({"font-size": size + "px"});
        };

        return TextWidget;
    });
/*global window*/
define('widget/ImageWidget',["jquery", "widget/AnimatedWidget"],
    function ($, AnimatedWidget) {
        

        /**
         * Widget for displaying an image.
         *
         * The image is automatically scaled to fit however large the widget is, while preserving its aspect ratio.
         * Also works with SVGs.
         *
         * @author Bo Gotthardt
         * @constructor
         *
         * @param options
         */
        function ImageWidget(options) {
            AnimatedWidget.call(this, options);

            this.element.addClass("ImageWidget");

            this.image = $("<img src='" + this.options.src + "'/>").
                appendTo(this.element);

            var scope = this;
            this.on("resize", function () {
                scope._setScalingDimension();
            });

            this.image.on("load", function () {
                scope._setScalingDimension();
                scope.initialized.resolve();
            });
        }
        ImageWidget.prototype = Object.create(AnimatedWidget.prototype);

        /**
         * Set the image to scale to either height or width, so that it is always as large as possible without being larger than the window.
         * @private
         */
        ImageWidget.prototype._setScalingDimension = function () {
            var win = $(window);

            if (win.height() / win.width() < this.image.height() / this.image.width()) {
                this.element.addClass("windowIsWider");
            } else {
                this.element.removeClass("windowIsWider");
            }
        };

        return ImageWidget;
    });
/*global window*/
define('widget/WidgetBuilder',["jquery", "util/QueryParameters", "util/Logger", "util/Promise"],
    function ($, QueryParameters, Logger, Promise) {
        
        var log = new Logger("WidgetBuilder");

        function getWidgetConstructor(type) {
            var widgetClass;

            switch (type) {
            case "text":
                widgetClass = "widget/TextWidget";
                break;
            case "image":
                widgetClass = "widget/ImageWidget";
                break;
//            case "debug":
//                widgetClass = "widget/DebugWidget";
//                break;
//            case "cardflip":
//                widgetClass = "widget/CardFlipWidget";
//                break;
            // If adding a new class here, also add it to the Gruntfile under requirejs.compile.options.deps .
            default:
                log.error("Unknown widget type:", type);
                return Promise.rejected();
            }

            // Dynamically require the widget class needed.
            // Doing this rather that defining a static dependency on all the widgets means we can avoid loading all
            // external dependencies for all widgets immediately, even if they are never needed.
            var deferred = new $.Deferred();

            require([widgetClass], function (Widget) {
                deferred.resolve(Widget);
            });

            return deferred;
        }

        /**
         * Builder that can create the various different kinds of widgets based on the options provided.
         *
         * @author Bo Gotthardt
         * @constructor
         *
         * @param {Object} [presets] A map of preset names to their options.
         */
        function WidgetBuilder(presets) {
            this.presets = presets;
        }

        /**
         * Create a widget based on the options in the page's query parameters.
         *
         * @returns {Promise} A promise for the widget
         */
        WidgetBuilder.prototype.fromQueryParameters = function () {
            var parameters = new QueryParameters();
            var options = {};

            if (parameters.preset) {
                if (this.presets && this.presets[parameters.preset]) {
                    options = this.presets[parameters.preset];
                } else {
                    log.warn("Preset not found:", parameters.preset);
                }
            }

            Object.keys(parameters).forEach(function (parameter) {
                options[parameter] = parameters[parameter];
            });

            return getWidgetConstructor(options.type)
                .then(function (Widget) {
                    var widget = new Widget(options);

                    // If the page has been opened directly we will never get the activate event, so trigger it manually.
                    if (window === window.top || parameters.activate) {
                        widget.initialized.done(function () {
                            log.info("Widget loaded directly, activating immediately.");
                            widget.activate();
                        });
                    }

                    return widget;
                });
        };

        return WidgetBuilder;
    });
/*global window*/
require(["widget/WidgetBuilder"],
    function (WidgetBuilder) {
        

        new WidgetBuilder(window.presets).fromQueryParameters()
            .done(function (widget) {
                window.widget = widget;
            });
    });
define("main", function(){});
